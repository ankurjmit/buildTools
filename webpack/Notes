=============================================================WEBPACK==========================================================================================

-> File loader is used for loading image.we import image from its path in js file.webpack can load js by default but for image it will check
	for loader if any present in webpack.config.js.File-loader is the loader used for images.

-> For importing css we need another loader.
	-> css-loader -> it is used to import css in js file.
	-> style-loader -> it will add style tag to head of html and add css classes to that style tag.

-> SASS/SCSS ->	
{
	test:/\.scss$/,
	use:['style-loader','css-loader','sass-loader']
}
-> Order of loaders in array is importatnt as it will execute right to left.
	1st it will run sass loader to convert scss to css;
	2nd it will run css laoder to make css importable to js file;
	3rd it will run style-loader to add a style tag to head and add css code to it.

-> Babel tanspiler for ES6 to ES5

Plugins ==>>

->TerserPlugin for minification of bundle.js

-> Plugin For extracting css in a separate file -> miniCSSExtract plugin -> We need to remove style-loader as we don't need to add style tag
 to head now.We are adding a ling tag to include a style.css file to head tag now.
 

Browser Caching

-> When user load a page again and again , we can cache JS Bundle for this page, so that it does not load it again and again.But
	it give one problem that u change something in js file even then it will not load the latest bundle as it will fetch from cache.
-> To solve this problem we can we can change the bundle name whenever we are making some change in js file.Then new file must be loaded.Hence 	
	we got the latest code on every change
-> Adding new file to index.html again and again is not praticle, to solve this we can add output file name as 'bundle.[contenthash].js' and 
	for css style.[contenthash].css -> it will create new file with different name every time we make any change in js and css.if we change in js
	only then js bundle will get new name but css bundle will remain same.
-> It will increase the no of file in dist folder and we need to update index.html every time bundle name changed.

-> Cleaning of Dist Folder
	->Plugin -> CleanWebpackPlugin to clean dist folder before making new bundle and keeo only one file for js and one for css
-> Adding script and css dynamiclly to index.html 
	->Plugin HTMLWEBPACKPLUGIN-> for creating new index.html on every build with latest js and css bundle
	->We can pass a object to HTMLWEBPACKPLUGIN plugin where we can defile title of page,location of file which will be generated by this plugin
	-> check github page for more details
	-> We can create template for this using handlebar or mustache
->




-> Production and develop mode
	->in webpack.config.js we can set mode to development or production or none
	-> In Development mode it used source map which allow us to debug any error
	-> In production mode , it will provide a minified bundle file where debugig is not possible(Plungins for minification run in this mode )
	-> to access mode use -> process.env.NODE_ENV
	-> We can create two files for webpack config one for development(webpack.dev.config.js) , one for production(webpack.production.config.js)
	-> We can add different config for both modes in their respective webpack config file.
	-> To run webpack add a script in package.json like build:'webpack --config webpack.production.config.js'

-> Webpack dev server
	-> npm i webpack-dev-server
	-> add devServer to webpack config
	-> Whenever we change , it will re-load the page own it own



-> Multi page application
	-> Code Spliting -> Make entry a object having multiple entry files which make different chunks with this name.
	-> in output filename should be like [name].[contenthash].js -> it will make chunks with different name and apply same for css chunks
	-> To make different html files for different page -> use multiple instance of HTMLWEBPACKPLUGIN with different config which will tell
		what will be names of differnt html file and which js bundle should be included in which file.
	-> chunks name are same as entry point name
	-> What if we have common js in different chunks then by default webpack will bundle that js library in each bundle making both chunks
		big.-> To solve this issue webpack a config "optimization" (split chunk config)-> it will separate out the common code in vendor chunk	
		so that each chunk don't have repeated code.Then we need to include this common vendor chunk to all page by adding it in HTMLWEBPACKPLUGIN
		config.
	-> Webpack make vendor chunk if size of chunk exceds 70kb.-> if we want to make separate chunk even if less then 70kb then we need to 
		provide config in "optimization" the "minSize" value.
	->

-> Webpack support import export out of the box
-> npm run webpack -> by default it will pick webpack.config.js file .You can also provide any file name like webpack --config sample.js

 
-> Prior to webpack, front-end developers would use tools like grunt and gulp to process these assets and move them from their /src folder into their /dist or /build directory. 
The same idea was used for JavaScript modules, but tools like webpack will dynamically bundle all dependencies (creating what's known as a dependency graph).
This is great because every module now explicitly states its dependencies and we'll avoid bundling modules that aren't in use.

-> One of the coolest webpack features is that you can also include any other type of file, besides JavaScript, for which there is a loader. 
This means that the same benefits listed above for JavaScript (e.g. explicit dependencies) can be applied to everything used in building a website or web app. 
Let's start with CSS, as you may already be familiar with that setup.

-> Loading css-> npm install --save-dev style-loader css-loader

-> loading image -> npm install --save-dev file-loader

-> Now, when you import MyImage from './my-image.png', that image will be processed and added to your output directory and the MyImage variable will 
contain the final url of that image after processing. When using the css-loader, as shown above, a similar process will
 occur for url('./my-image.png') within your CSS. The loader will recognize this is a local file, and replace the './my-image.png' path with the 
 final path to the image in your output directory. The html-loader handles <img src="./my-image.png" /> in the same manner.


-> File -loader is used for font-file also along with images

-> csv-loader
-> xml-loader for xml files 

============================Output=================================================================
->
output: {
      filename: '[name].bundle.js',-> entry point file name would replace the [name] 
      path: path.resolve(__dirname, 'dist')
    }
-> it would generate different bundle for diffent entry points.like index.bundle.js,app.bundle.js
-> it became difficult to manually update "index.html" as we create different bundles again and again,so to avoid these
	we have HtmlWebpackPlugin -> it will automatically create index.html and include all bundle in script tag.
->	plugins: [
     new HtmlWebpackPlugin({
       title: 'Output Management'-> We can provide title and all other otptions if we want
     })
   ],

-> In general it's good practice to clean the /dist folder before each build, so that only single copy of  files will be generated. 
-> clean-webpack-plugin ->  new CleanWebpackPlugin() for cleaning dist folder on every build.
-> The manifest file is the one that webpack keeps to track how all the modules map to the output bundles.


============================Development mode=======================================================

-> mode: 'development' -> for develop mode
-> source maps -> When webpack bundles your source code, it can become difficult to track down errors and warnings to their original location. 
For example, if you bundle three source files (a.js, b.js, and c.js) into one bundle (bundle.js) and one of the source files contains an error, 
the stack trace will simply point to bundle.js. This isn't always helpful as you probably want to know exactly which source file the error came from.

In order to make it easier to track down errors and warnings, JavaScript offers source maps, which maps your compiled code back to your 
original source code. If an error originates from b.js, the source map will tell you exactly that.

->devtool: 'inline-source-map',

-> Choosing a Development Tool
There are a couple of different options available in webpack that help you automatically compile your code whenever it changes:

-> webpack's Watch Mode   -> "watch": "webpack --watch",
-> webpack-dev-server     -> The webpack-dev-server provides you with a simple web server and the ability to use live reloading. 
-> devServer: {
     contentBase: './dist' -> This tells webpack-dev-server to serve the files from the dist directory on localhost:8080.
	}
-> webpack-dev-server doesn't write any output files after compiling. Instead, it keeps bundle files in memory and serves them as if they were real 
	files mounted at the server's root path. If your page expects to find the bundle files in different path, you can change this with the publicPath 
	option in the dev server's configuration.
->  "start": "webpack-dev-server --open",

-> webpack-dev-middleware -> 

============================================================Code Splitting====================================================================

-> Code splitting is one of the most compelling features of webpack. This feature allows you to split your code into various bundles which can then be 
	loaded on demand or in parallel. It can be used to achieve smaller bundles and control resource load prioritization which, if used correctly, 
	can have a major impact on load time.

-> There are three general approaches to code splitting available:

	->Entry Points: Manually split code using entry configuration.
		-> Disadvantage->
			-> If there are any duplicated modules between entry chunks they will be included in both bundles
			-> It isn't as flexible and can't be used to dynamically split code with the core application logic
			-> SplitChunksPlugin is used to overcome these Disadvantage 
			
	->Prevent Duplication: Use the SplitChunksPlugin to dedupe and split chunks.
		-> The SplitChunksPlugin allows us to extract common dependencies into an existing entry chunk or an entirely new chunk
		-> optimization: {
				splitChunks: {
				chunks: 'all'
				}
			}
			
	->Dynamic Imports: Split code via inline function calls within modules.
		 output: {
			filename: '[name].bundle.js',
     		chunkFilename: '[name].bundle.js',-> for common code this is the chunk name 
			path: path.resolve(__dirname, 'dist')
		}
 
 =====================================================Lazy Loading===========================================================================
 -> Lazy, or "on demand", loading is a great way to optimize your site or application. This practice essentially involves splitting your code 
	at logical breakpoints, and then loading it once the user has done something that requires, or will require, a new block of code.
	This speeds up the initial load of the application and lightens its overall weight as some blocks may never even be loaded.
-> 

=======================================================Caching================================================================================
-> broswer can cache the chunks so that they do not need to load it again and again.But if we change something in js and do not change the 
	chunk then it will not load the latest code.To avoide this we have chnage the name of chunk on every change using new hash code..
	
-> We can use the output.filename substitutions setting to define the names of our output files. webpack provides a method of templating the filenames
 using bracketed strings called substitutions. The [contenthash] substitution will add a unique hash based on the content of an asset. 
 When the asset's content changes, [contenthash] will change as well.
 
 -> in output config of webpack -> filename: '[name].[contenthash].js'
 
 -> It's also good practice to extract third-party libraries, such as lodash or react, to a separate vendor chunk as they are less likely to change than 
	our local source code. This step will allow clients to request even less from the server to stay up to date. This can be done by using the 
	cacheGroups option of the SplitChunksPlugin
-> optimization: {
     runtimeChunk: 'single',
     splitChunks: {
       cacheGroups: {
         vendor: {
           test: /[\\/]node_modules[\\/]/,
           name: 'vendors',
           chunks: 'all'
         }
       }
     }
	}


===================================================Performance===============================================================================
-> Use the latest webpack version
-> Minimize the number of items in resolve.modules
-> Use fewer/smaller libraries.
-> Use the SplitChunksPlugin in Multi-Page Applications.
-> Remove unused code.
-> Only compile the part of the code you are currently developing on
-> Compile in Memory using -> webpack-dev-server
-> Be aware of the performance differences of the different devtool settings.
-> "eval" has the best performance, but doesn't assist you for transpiled code.
-> The cheap-source-map variants are more performant, if you can live with the slightly worse mapping quality.
-> Use a eval-source-map variant for incremental builds.
-> In most cases, cheap-module-eval-source-map is the best option.
-> Avoid Production Specific Tooling
-> never use Source Maps for production
======================================================Hot Module Replacement==================================================================
-> Hot Module Replacement (or HMR) is one of the most useful features offered by webpack. It allows all kinds of modules to be
	updated at runtime without the need for a full refresh.
-> HMR is not intended for use in production, meaning it should only be used in development
->  new webpack.HotModuleReplacementPlugin() in Plugins
-> 

======================================================Tree Shaking===========================================================================
-> Tree shaking is a term commonly used in the JavaScript context for dead-code elimination. It relies on the static structure of ES2015 module 
	syntax, i.e. import and export. The name and concept have been popularized by the ES2015 module bundler rollup.
-> So, what we've learned is that in order to take advantage of tree shaking, you must...

-> Use ES2015 module syntax (i.e. import and export).
-> Ensure no compilers transform your ES2015 module syntax into CommonJS modules (this is the default behavior of popular Babel preset @babel/preset-env
	Add a "sideEffects" property to your project's package.json file.
	Use production mode configuration option to enable various optimizations including minification and tree shaking.
	You can imagine your application as a tree. The source code and libraries you actually use represent the green, living leaves of the tree. 
	Dead code represents the brown, dead leaves of the 
	tree that are consumed by autumn. In order to get rid of the dead leaves, you have to shake the tree, causing them to fall.


======================================================Production=============================================================================
->  In development, we want strong source mapping and a localhost server with live reloading or hot module replacement. In production,
 our goals shift to a focus on minified bundles, lighter weight source maps, and optimized assets to improve load time. With this logical separation at hand, 
 we typically recommend writing separate webpack configurations for each environment.
 
-> We can have 3 files . 1. webpack.prod.js 2. webpack.dev.js for development 3. webpack.common.js

==========================================================Progressive Web Application========================================================================
-> Progressive Web Applications (or PWAs) are web apps that deliver an experience similar to native applications. There are many things that can contribute to that. 
	Of these, the most significant is the ability for an app to be able to function when offline. 
	This is achieved through the use of a web technology called Service Workers.
-> 
==============================================================Integrations=======================================================================================
-> webpack is a module bundler like Browserify or Brunch. It is not a task runner like Make, Grunt, or Gulp.
-> Bundlers help you get your JavaScript and stylesheets ready for deployment, transforming them into a format that's suitable for the browser. 
	For example, JavaScript can be minified or split into chunks and lazy-loaded to improve performance. Bundling is one of the most important challenges in web 
	development, and solving it well can remove a lot of pain from the process.
-> Often webpack users use npm scripts as their task runner. 
